program ::= declaration* EOF

# no variable decl - assignment is declaration so it's an expression statement
# todo: maybe arrays should behave the same? otoh i haven't changed my expression grammar since
# 1870 and i'm not starting now
declaration ::= funDecl | procDecl | classDecl | arrayDecl | statement

statement ::= exprStmt
                | globalStmt
                | forStmt
                | whileStmt
                | doStmt
                | ifStmt
                | switchStmt

# exclusive - don't want it used in procs but side effect is the grammar being tight on its usage - less work later!!
return ::= "return" expression

exprStmt ::= expression
globalStmt ::= 
forStmt ::= "for" IDENTIFIER "=" expression "to" expression declaration* "next" IDENTIFIER
whileStmt ::= "while" expression declaration* "endwhile"
# todo: needs endUntil or similar? dunno how i'm going to implement this
doStmt ::= "do" declaration* "until" expression
# probably a sexy way to describe this similar to "else if" in a normal grammar, i'm too tired, this flat structure works
# (if slighly clunkily)
ifStmt ::= "if" expression "then" declaration* ("elseif" expression "then" declaration*)* ("else" declaration*)? "endif"
switchStmt ::= "switch" expression ("case" expression ":" declaration*)* ("default" ":" declaration*) "endswitch"

expression ::= assignment

assignment ::= ((call ".")? IDENTIFIER "=" assignment) | logicOr
logicOr ::= logicAnd ("OR" logicAnd)*
logicAnd ::= equality ("AND" equality)*
equality ::= comparison (("==" | "!=") comparison)*
comparison ::= term (("<" | "<=" | ">" | ">=") term)*
term ::= factor (("+" | "-") factor)*
factor ::= unary (("*" | "/") unary)*
unary ::= ("NOT" | "-" | "new") unary | call
call ::= super ("(" arguments? ")" | "." IDENTIFIER)*
super ::= "super" "." IDENTIFIER | grouping
grouping ::= "(" expression ")" | primary
primary ::= "self" | STRING | INT | FLOAT | IDENTIFIER

funDecl ::= "function" IDENTIFIER "(" parameters? ")" (declaration | return)* "endfunction"
procDecl ::= "procedure" IDENTIFIER "(" parameters? ")" declaration* "endprocedure"
arrayDecl ::= 
classDecl ::= "class" IDENTIFIER ("inherits" IDENTIFIER)? (classMember | classMethod)* "endclass"

classMember ::= storageSpecifier? IDENTIFIER ("=" expression)?
classMethod ::= storageSpecifier? funDecl | procDecl

storageSpecifier ::= "public" | "private"

singleParameter ::= IDENTIFIER (":" "byVal" | "byRef")?
parameters ::= singleParameter  ("," singleParameter)*
arguments ::= expression ("," expression)*